Data Reconciliation for a Single Unit - Economizer
==================================================

This notebook demonstrates data reconciliation with a single unit model,
an economizer. Data for this example was generated by adding noise to
supercritical power plant simulations.

Why reconcile data?
~~~~~~~~~~~~~~~~~~~

Data reconciliation uses mass and energy balances along with redundant
measurements to improve data quality by:

1. reducing measurement error,
2. ensuring measurements satisfy mass and energy balances, and
3. filling in unmeasured quantities.

Data reconciliation is used to refine process data before parameter
estimation.

1. Read Plant Data
------------------

The first step is to read in process data. In this case, data was
simulated by adding measurement error to supercritical steam cycle
simulation results. IDAES includes functions to read process data,
convert units to match a model, and map data to a model.

.. code:: ipython3

    # IDAES module with functions to read, analyze and visualize plant data
    import idaes.dmf.model_data as da
    # Suppress some warnings
    from idaes.logger import getLogger
    import logging
    getLogger('idaes.core').setLevel(logging.ERROR)

Process data is contained in two CSV files, a data file and a metadata
file. The first column in the data file is row indexes and the first row
is process measurement tags. The index column has an entry for each data
row, and is often a time-stamp. The data file format is illustrated by
the table below.

+----------+-------------+-------------+--------------+-------+
|          | tag1        | tag2        | tag3         | ...   |
+==========+=============+=============+==============+=======+
| index1   | data(1,1)   | data(1,2)   | data(1, 3)   | ...   |
+----------+-------------+-------------+--------------+-------+
| index2   | data(2,1)   | data(2,2)   | data(2, 3)   | ...   |
+----------+-------------+-------------+--------------+-------+
| ...      | ...         | ...         | ...          | ...   |
+----------+-------------+-------------+--------------+-------+

The metadata file contains information about the tags including units of
measurement, description, and model mapping information. The meta data
format is show below, any of the columns my be empty.

\| \| \| \| \| \| \|-------\|---
---------------\|---------------\|-------------------\|-----------------------------------------------------\|
\| tag1 \| model reference 1 \| description 1 \| unit of measure 1 \|
Additional comments, additional columns are ignored \| \| tag2 \| model
reference 2 \| description 2 \| unit of measure 2 \| ... \| \| tag3 \|
model reference 3 \| description 3 \| unit of measure 3 \| ... \| \| ...
\| ... \| ... \| ... \| ... \|

Once the process data is read in, the data is assigned to bins based on
the value in a given column, in this case gross power. Dividing the data
into bins allows rough estimation of measurement uncertainty.

.. code:: ipython3

    # Read data and column metadata
    df, df_meta = da.read_data("plant_data.csv", "plant_data_meta.csv")
    
    # Add bin information where the data is sorted into 5 MW bins based on the "GROSS_POWER" column
    # A bin number column is added along with a column for nominal gross power in the bin. 
    bin_count = da.bin_data(df, bin_by="POWER_GROSS", bin_no="bin_no", bin_nom="bin_power", bin_size=5e6)
    
    # Calculate the standard deviation by bin for each column.  The resulting standard devations can be 
    # accessed like so: bin_stdev[bin number][column name]
    bin_stdev = da.bin_stdev(df, bin_no="bin_no")

It can be useful to visualize the measurement data and estimated
uncertainty. The following creates box and whisker plots for each tag
based on the data bins. A large number of plots may be created, so to
manage them more easily, they are saved as PDFs and merged into a single
multi-page PDF document. The deafault file name for the resulting PDF is
"data\_plot\_book.pdf."

.. code:: ipython3

    # Create a pdf book of plots that shows box and whisker plots for each column by bin
    import os
    if not os.path.isfile("data_plot_book.pdf"):
        da.data_plot_book(df, bin_nom="bin_power", xlabel="gross power (W)", metadata=df_meta, file="data_plot_book.pdf")
    # There should now be a data_plot_book.pdf file in this directory

2. Create Unit model
--------------------

Now that we have the plant data, we need to create a unit model that we
can use for data reconciliation. Although we need a model that has just
mass and energy balances and feasibility constraints for the data
reconciliation problem, we start with the full economizer model here.
Using the same model for data reconciliation, parameter estimation,
validation, and simulation reduces the work required to move between
steps in the workflow.

Once the full model is created, constraints that are not needed for data
reconciliation can be deactivated.

.. code:: ipython3

    # Import models
    from idaes.core import FlowsheetBlock
    from idaes.power_generation.properties.IdealProp_FlueGas import FlueGasParameterBlock
    from idaes.generic_models.properties import iapws95
    from idaes.power_generation.unit_models.boiler_heat_exchanger import (
        BoilerHeatExchanger, 
        TubeArrangement, 
        DeltaTMethod
    )
    import pyomo.environ as pyo

.. code:: ipython3

    # Create flowsheet with economizer
    m = pyo.ConcreteModel()
    m.fs = FlowsheetBlock(default={"dynamic": False})
    m.fs.prop_water = iapws95.Iapws95ParameterBlock()
    m.fs.prop_fluegas = FlueGasParameterBlock()
    
    m.fs.econ = BoilerHeatExchanger(default={
            "side_1_property_package": m.fs.prop_water,
            "side_2_property_package": m.fs.prop_fluegas,
            "has_pressure_change": True,
            "has_holdup": False,
            "delta_T_method": DeltaTMethod.counterCurrent,
            "tube_arrangement": TubeArrangement.inLine,
            "side_1_water_phase": "Liq",
            "has_radiation": False
        }
    )

.. code:: ipython3

    # Set up and initialize the model
    
    # The steam properties use enthalpy as a state variable, so use the known 
    # temperature and pressure to calculate the feedwater inlet enthalpy
    h = iapws95.htpx(563.706, 2.5449e7)
    
    m.fs.econ.side_1_inlet.flow_mol[0].fix(24678.26) # mol/s
    m.fs.econ.side_1_inlet.enth_mol[0].fix(h) #J/mol         
    m.fs.econ.side_1_inlet.pressure[0].fix(2.5449e7) # Pa
    
    # Set the flue gas flow and composition
    fg_rate = 28.3876e3  # mol/s equivalent of ~1930.08 klb/hr
    fg_comp = { # mol fraction of flue gas components
        "H2O":8.69/100,
        "CO2":14.49/100,
        "O2":2.47/100,
        "NO":0.0006,
        "SO2":0.002,
    }
    # The rest is N2
    fg_comp["N2"] = 1 - sum(fg_comp[i] for i in fg_comp)
    
    # Set economizer inlets
    for c in fg_comp:
        m.fs.econ.side_2_inlet.flow_component[0, c].fix(fg_rate*fg_comp[c])    
    m.fs.econ.side_2_inlet.temperature[0].fix(682.335)  # K
    m.fs.econ.side_2_inlet.pressure[0].fix(100145)  # Pa
    
    # Set economizer design variables and parameters
    ITM = 0.0254  # inch to meter conversion
    # Based on NETL Baseline Report Rev4
    m.fs.econ.tube_thickness.fix(0.188*ITM)  # tube thickness
    m.fs.econ.tube_di.fix((2.0 - 2.0 * 0.188)*ITM) # calc inner diameter
    m.fs.econ.pitch_x.fix(3.5*ITM)
    m.fs.econ.pitch_y.fix(5.03*ITM)
    m.fs.econ.tube_length.fix(53.41*12*ITM)  # use tube length (53.41 ft)
    m.fs.econ.tube_nrow.fix(36*2.5) # use to match baseline performance
    m.fs.econ.tube_ncol.fix(130) # 130 from thermoflow
    m.fs.econ.nrow_inlet.fix(2)
    m.fs.econ.delta_elevation.fix(50)
    m.fs.econ.tube_r_fouling = 0.000176
    m.fs.econ.shell_r_fouling = 0.00088
    m.fs.econ.fcorrection_htc.fix(1.5)
    m.fs.econ.fcorrection_dp_tube.fix(1.0)
    m.fs.econ.fcorrection_dp_shell.fix(1.0)

.. code:: ipython3

    # Initialize economizer
    m.fs.econ.initialize(
        state_args_1={
            "flow_mol": m.fs.econ.side_1_inlet.flow_mol[0].value,
            "pressure": m.fs.econ.side_1_inlet.pressure[0].value,
            "enth_mol": m.fs.econ.side_1_inlet.enth_mol[0].value,
        },
        state_args_2={
            "flow_component":{
                "H2O": m.fs.econ.side_2_inlet.flow_component[0, "H2O"].value,
                "CO2": m.fs.econ.side_2_inlet.flow_component[0, "CO2"].value,
                "N2": m.fs.econ.side_2_inlet.flow_component[0, "N2"].value,
                "O2": m.fs.econ.side_2_inlet.flow_component[0, "O2"].value,
                "NO": m.fs.econ.side_2_inlet.flow_component[0, "NO"].value,
                "SO2": m.fs.econ.side_2_inlet.flow_component[0, "SO2"].value,
            },
            "temperature": m.fs.econ.side_2_inlet.temperature[0].value,
            "pressure": m.fs.econ.side_2_inlet.pressure[0].value,
        }
    )


.. parsed-literal::

    2020-07-01 07:52:39 [INFO] idaes.init.fs.econ.side_1: Initialization Complete
    2020-07-01 07:52:39 [INFO] idaes.init.fs.econ.side_2: Initialization Complete


3. Simplify to Mass and Energy Balances
---------------------------------------

For data reconciliation, the model should be reduced to mass and energy
balances and potentially limited performance constraints to keep the
results feasible.

.. code:: ipython3

    # Deactivate constraints for heat transfer
    m.fs.econ.overall_heat_transfer_coefficient_eqn.deactivate()
    m.fs.econ.rcond_wall_eqn.deactivate()
    m.fs.econ.hconv_shell_total_eqn.deactivate()
    m.fs.econ.hconv_shell_conv_eqn.deactivate()
    m.fs.econ.N_Nu_shell_eqn.deactivate()
    m.fs.econ.N_Pr_shell_eqn.deactivate()
    m.fs.econ.deltaP_shell_eqn.deactivate()
    m.fs.econ.friction_factor_shell_eqn.deactivate()
    m.fs.econ.N_Re_shell_eqn.deactivate()
    m.fs.econ.v_shell_eqn.deactivate()
    m.fs.econ.hconv_tube_eqn.deactivate()
    m.fs.econ.N_Nu_tube_eqn.deactivate()
    m.fs.econ.N_Pr_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_uturn_eqn.deactivate()
    m.fs.econ.deltaP_tube_friction_eqn.deactivate()
    m.fs.econ.friction_factor_tube_eqn.deactivate()
    m.fs.econ.N_Re_tube_eqn.deactivate()
    m.fs.econ.v_tube_eqn.deactivate()
    m.fs.econ.LMTD.deactivate()

4. Map Data to the Model
------------------------

Although the model mapping can be included in the tag metadata file,
here we just add the mapping information to the tag metadata after
reading the data. Sometime a data set may be used with more than one
model or you may want to examine data before creating a model, in which
case it is convenient to defer mapping the data to the model as we have
done here.

.. code:: ipython3

    df_meta["ECON_OUT_F"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].flow_mol"
    df_meta["ECON_OUT_T"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].temperature"
    df_meta["ECON_OUT_P"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].pressure"
    df_meta["BFW_F"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].flow_mol"
    df_meta["BFW_T"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].temperature"
    df_meta["BFW_P"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].pressure"
    df_meta["FG_2_ECON_Fm"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].flow_mass"
    df_meta["FG_2_ECON_T"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].temperature"
    df_meta["FG_2_ECON_P"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].pressure"
    df_meta["FG_2_AIRPH_Fm"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].flow_mass"
    df_meta["FG_2_AIRPH_T"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].temperature"
    df_meta["FG_2_AIRPH_P"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].pressure"

.. code:: ipython3

    # Add the model references to the tag metadata based on the strings above.
    da.upadate_metadata_model_references(m, df_meta)

.. code:: ipython3

    # Create a dictionary of data tags that we want to use for the data reconciliation problem.  
    # The key is the tag and the value is a reference to a quantity in the model.
    data_tags = {k:v["reference"][0] for k, v in df_meta.items() if v["reference"] is not None}

.. code:: ipython3

    # Now for result output, the data reconciliation usually can give full stream information for a flowsheet
    # including quantities that are unmeasured.  To more easily use the results, it is good practice to map most of
    # the data reconciliation results to flowsheet stream names.  
    import idaes.core.util.tables as ta
    
    # This function creates a dictionary of streams based of streams based on model arcs.  The function
    # also takes an addtional set of stream-like objects for add to the stream dictionary.  In this case,
    # there is a single unit and the flowsheet doesn't contain any arcs, so we add the economized inlet and
    # outlet ports to the stream dictionary.
    stream_dict = ta.arcs_to_stream_dict(
        m, 
        additional={
            "BFW": m.fs.econ.side_1_inlet,
            "ECON_OUT": m.fs.econ.side_1_outlet,
            "FG_2_ECON": m.fs.econ.side_2_inlet,
            "FG_2_AIRPH": m.fs.econ.side_2_outlet,
        },
        sort=True,
    )
    
    # The next function convers the stream dictionary into a dictionary of state block representing the
    # streams at a given time point.  In this case, we have a steady state model, so we only have one 
    # time point (0).
    state_dict = ta.stream_states_dict(stream_dict, time_point=0)
    
    # The 'tag_state_quantities()' function below iterates through the state block dictionary and 
    # creates tags for the listed attributes by combining the state block label with the attribute label 
    # in the labels argument.  For example, pressure in the S001 state block would get the tag 'S001_P'.
    recon_tags = ta.tag_state_quantities(
        blocks=state_dict, 
        attributes=(
            "flow_mass", 
            "flow_mol", 
            "enth_mol", 
            "temperature", 
            "pressure", 
            ("flow_component", "O2"),
            ("flow_component", "NO"),
            ("flow_component", "N2"),
            ("flow_component", "SO2"),
            ("flow_component", "CO2"),
            ("flow_component", "H2O"),
        ), 
        labels=("_Fm", "_F", "_h", "_T", "_P", "_F[O2]", "_F[NO]", "_F[N2]", "_F[SO2]", "_F[CO2]", "_F[H2O]"),
    )
    
    # Any addtional tags can be added.  This is required for tags that cannot be systematically generated 
    # from the model streams.
    recon_tags["ECON_Q"] = m.fs.econ.heat_duty[0]

5. View model flowsheet
-----------------------

Model results or other quantities can be added to a process flow
diagram. The PFD was drawn beforehand and the model results are added to
tagged locations on the PFD.

.. code:: ipython3

    from idaes.core.util.misc import svg_tag  # utility to place numbers/text in an SVG
    
    with open("econ.svg", "r") as f:
        s = svg_tag(svg=f, tags={"subtitle":"Initialized Model"})
        s = svg_tag(svg=s, tags=recon_tags, outfile="econ_init.svg")

.. code:: ipython3

    from IPython.display import SVG, display
    
    display(SVG(s))



.. image:: output_21_0.svg


6. Write Objective
------------------

Next we write the objective function and additional constraints for the
data reconciliation problem. The objective is

.. math:: \min \sum_i \left(\frac{x_{\text{data}, i} - x_{\text{model}, i}}{\sigma_i} \right)^2

Where :math:`i \in \{\text{Measured Quantities}\}` and :math:`\sigma_i`
is the standard deviation of measurement i. In this case, for lack of
better information, the standard deviation was estimated by binning the
data and calculating the standard deviation of each measured variable in
each bin.

.. code:: ipython3

    # Add model parameters to contain measured data.  These are mutable so we can set a specific data point later.
    m.data = pyo.Param(data_tags, mutable=True, doc="Process data for a specific point in time.")
    m.data_stdev = pyo.Param(data_tags, mutable=True, doc="Process data standard deviation.")

.. code:: ipython3

    # The 'set_data' function below takes data from the process data DataFrame and updates the
    # data parameters in the model.
    def set_data(m, df, data_tags, index=None, indexindex=None):
        if index is None:
            index = df.index[indexindex]
        m.bin_no = df.iloc[index]["bin_no"]
        for t in data_tags:
            m.data[t] = df.iloc[index][t]
            m.data_stdev[t] = bin_stdev[m.bin_no][t]

.. code:: ipython3

    # So we have something reasonable to start, set the data attached to the model to the first 
    # data point.
    set_data(m, df, data_tags, indexindex=0)

Add an expression for error divided by the standard deviation, and use
it to write the data reconciliation objective function.

.. code:: ipython3

    @m.Expression(data_tags)
    def err(m, i):
        return (m.data[i] - data_tags[i])/m.data_stdev[i]
    
    m.objective = pyo.Objective(expr=sum(m.err[t]**2 for t in m.err))

Add constraints that ensure reasonable temperature and keep the flue gas
composition correct.

.. code:: ipython3

    # Limit temperature approach
    m.c1 = pyo.Constraint(expr=m.fs.econ.deltaT_1[0] >= 1.0)
    m.c2 = pyo.Constraint(expr=m.fs.econ.deltaT_2[0] >= 1.0)
    
    # Constrain flue gas composition
    m.flow_fg = pyo.Var(initialize=fg_rate)
    @m.Constraint(fg_comp)
    def eq_fg_comp(b, c):
        return m.fs.econ.side_2_inlet.flow_component[0, c] == fg_comp[c]*m.flow_fg

7. Solve Optimization
---------------------

Now we need to solve the data reconciliation problem for every data
point. The important results are stored in two DataFrames ``df_result``,
which contains results tagged based on model stream names to be used in
the parameter estimation step and ``df_result_cmp`` which contains
reconciled data based on the original measurement tags and can be used
to compare the original measurements to the reconciled results.

.. code:: ipython3

    # Make sure the inlet and outlet ports are unfixed.  We want to leave these free 
    # to best match the data.
    m.fs.econ.side_1_inlet.unfix()
    m.fs.econ.side_2_inlet.unfix()
    m.fs.econ.side_1_outlet.unfix()
    m.fs.econ.side_2_outlet.unfix()

.. code:: ipython3

    # Create a Pyomo solver object
    solver = pyo.SolverFactory('ipopt')

.. code:: ipython3

    import pandas as pd
    # Add bin information to reconciliation results so it can be used in parameter estimation
    df_result = pd.DataFrame(columns=list(recon_tags.keys())+["termination", "bin_no", "bin_power"], index=df.index)
    df_result_cmp = pd.DataFrame(columns=list(data_tags.keys())+["termination"], index=df.index)
    
    # Loop through each data point and solve the data reconciliation problem. 
    for i in df.index:
        set_data(m, df, data_tags, index=i)
        res = solver.solve(m)
        tc = str(res.solver.termination_condition)
        df_result.iloc[i]["termination"] = tc
        df_result.iloc[i]["bin_no"] = df.iloc[i]["bin_no"]
        df_result.iloc[i]["bin_power"] = df.iloc[i]["bin_power"]
        df_result_cmp.iloc[i]["termination"] = tc
        for t in recon_tags:
            df_result.iloc[i][t] = pyo.value(recon_tags[t])
        for t in data_tags:
            df_result_cmp.iloc[i][t] = pyo.value(data_tags[t])
        # Show something so you can tell progress is happening
        print(f"{i} -- {tc}, objective: {pyo.value(m.objective)}")


.. parsed-literal::

    0 -- optimal, objective: 3.1622013606259403
    1 -- optimal, objective: 0.8197916348691104
    2 -- optimal, objective: 1.4704841795758476
    3 -- optimal, objective: 1.1898903619192618
    4 -- optimal, objective: 6.266902064585048
    5 -- optimal, objective: 2.3537989757333984
    6 -- optimal, objective: 0.5232362334703197
    7 -- optimal, objective: 1.023434788995793
    8 -- optimal, objective: 1.6923646000308887
    9 -- optimal, objective: 5.200181602792343
    10 -- optimal, objective: 2.0256788832442476
    11 -- optimal, objective: 1.3755282573107606
    12 -- optimal, objective: 1.8040411950227526
    13 -- optimal, objective: 1.0820452722033849
    14 -- optimal, objective: 2.872550834678504
    15 -- optimal, objective: 4.679431401771467
    16 -- optimal, objective: 2.528546248998855
    17 -- optimal, objective: 3.419056606899059
    18 -- optimal, objective: 0.6733248046041341
    19 -- optimal, objective: 1.319117422958446
    20 -- optimal, objective: 2.591126369763101
    21 -- optimal, objective: 0.7284969800022673
    22 -- optimal, objective: 3.0960880080305375
    23 -- optimal, objective: 8.046882712392835
    24 -- optimal, objective: 9.434438819029042
    25 -- optimal, objective: 2.9086660605554826
    26 -- optimal, objective: 5.764854776323218
    27 -- optimal, objective: 1.5869850001202495
    28 -- optimal, objective: 0.9849706870360314
    29 -- optimal, objective: 5.42069662270512
    30 -- optimal, objective: 0.16069807809737502
    31 -- optimal, objective: 1.9662633227541513
    32 -- optimal, objective: 4.63192846843906
    33 -- optimal, objective: 0.7898326457669481
    34 -- optimal, objective: 4.935316816207512
    35 -- optimal, objective: 2.7822175536769236
    36 -- optimal, objective: 3.7936042118830264
    37 -- optimal, objective: 7.39969441058754
    38 -- optimal, objective: 1.8234931889047656
    39 -- optimal, objective: 8.123278203552301
    40 -- optimal, objective: 2.466989330263795
    41 -- optimal, objective: 2.0590537595046277
    42 -- optimal, objective: 4.8248900459122925
    43 -- optimal, objective: 2.9053626799318897
    44 -- optimal, objective: 1.2572997144473643
    45 -- optimal, objective: 2.762645380939183
    46 -- optimal, objective: 3.910604606261536
    47 -- optimal, objective: 0.3638454718893757
    48 -- optimal, objective: 6.482123086791777
    49 -- optimal, objective: 0.8862884524239302
    50 -- optimal, objective: 0.3533378896238791
    51 -- optimal, objective: 0.6741934666896557
    52 -- optimal, objective: 1.4465665980891886
    53 -- optimal, objective: 2.365692115699846
    54 -- optimal, objective: 1.4292836233966724
    55 -- optimal, objective: 11.608835808935835
    56 -- optimal, objective: 2.5845585364935517
    57 -- optimal, objective: 2.2280318358779247
    58 -- optimal, objective: 2.4953939655522572
    59 -- optimal, objective: 1.6472887590076
    60 -- optimal, objective: 8.024825566331184
    61 -- optimal, objective: 5.943553444690104
    62 -- optimal, objective: 2.3357860625599765
    63 -- optimal, objective: 4.385139025177306
    64 -- optimal, objective: 0.5607805981597113
    65 -- optimal, objective: 2.176847135635652
    66 -- optimal, objective: 2.8232836736976386
    67 -- optimal, objective: 4.396906443658487
    68 -- optimal, objective: 3.3918559300376927
    69 -- optimal, objective: 0.6148795243219445
    70 -- optimal, objective: 0.3708280914480398
    71 -- optimal, objective: 0.8762641868566374
    72 -- optimal, objective: 3.008634294220509
    73 -- optimal, objective: 6.1782756837046335
    74 -- optimal, objective: 2.4515957167722315
    75 -- optimal, objective: 8.974736425709397
    76 -- optimal, objective: 1.7706655882252758
    77 -- optimal, objective: 3.1265189714765693
    78 -- optimal, objective: 5.205386216685977
    79 -- optimal, objective: 4.769597864830309
    80 -- optimal, objective: 4.816644746436785
    81 -- optimal, objective: 0.6532812835414419
    82 -- optimal, objective: 2.4965181358356983
    83 -- optimal, objective: 0.8032343482262125
    84 -- optimal, objective: 0.362824933753562
    85 -- optimal, objective: 1.5238238194806093
    86 -- optimal, objective: 3.8657878309490328
    87 -- optimal, objective: 1.722274966870726
    88 -- optimal, objective: 3.9538769694017852
    89 -- optimal, objective: 1.6523612442371727
    90 -- optimal, objective: 3.351063841684149
    91 -- optimal, objective: 1.2093955196399544
    92 -- optimal, objective: 1.5787045321363253
    93 -- optimal, objective: 3.4104193014724893
    94 -- optimal, objective: 1.263897891350209
    95 -- optimal, objective: 3.2950093864133936
    96 -- optimal, objective: 1.530697826703583
    97 -- optimal, objective: 2.0576162766855517
    98 -- optimal, objective: 1.733210252160938
    99 -- optimal, objective: 4.588275042310329
    100 -- optimal, objective: 0.929564607823724
    101 -- optimal, objective: 1.1035561284196604
    102 -- optimal, objective: 0.005402403281226591
    103 -- optimal, objective: 4.030350825817907
    104 -- optimal, objective: 2.5977688471873943
    105 -- optimal, objective: 3.7186572151967217
    106 -- optimal, objective: 2.220001230385389
    107 -- optimal, objective: 1.7361821672874513
    108 -- optimal, objective: 1.7827948173523989
    109 -- optimal, objective: 0.8012022277038632
    110 -- optimal, objective: 0.4890697265297288
    111 -- optimal, objective: 4.625396349830893
    112 -- optimal, objective: 4.07305004423305
    113 -- optimal, objective: 4.984164789951584
    114 -- optimal, objective: 4.500918344081792
    115 -- optimal, objective: 0.801241319826635
    116 -- optimal, objective: 2.687543401764775
    117 -- optimal, objective: 6.864934379080679
    118 -- optimal, objective: 3.0375805861817042
    119 -- optimal, objective: 2.494108889024753
    120 -- optimal, objective: 0.46083351785486587
    121 -- optimal, objective: 0.044471331591673866
    122 -- optimal, objective: 1.9091826645258623
    123 -- optimal, objective: 4.1539278628050536
    124 -- optimal, objective: 5.635821162569111
    125 -- optimal, objective: 4.722448584729824
    126 -- optimal, objective: 4.8384258645452904
    127 -- optimal, objective: 2.895359847032065
    128 -- optimal, objective: 0.17007028011236205
    129 -- optimal, objective: 0.9837813189594314
    130 -- optimal, objective: 8.052244544966166
    131 -- optimal, objective: 6.260349530091066
    132 -- optimal, objective: 2.572638735016494
    133 -- optimal, objective: 3.7332306499362953
    134 -- optimal, objective: 0.34006496250097834
    135 -- optimal, objective: 3.603279268837926
    136 -- optimal, objective: 2.5015728490600546
    137 -- optimal, objective: 0.3964133949983513
    138 -- optimal, objective: 0.14140404247121321
    139 -- optimal, objective: 8.317240586450486
    140 -- optimal, objective: 5.4244487095195275
    141 -- optimal, objective: 2.835771348358021
    142 -- optimal, objective: 1.5375770466937604
    143 -- optimal, objective: 3.6241716128086403
    144 -- optimal, objective: 4.954731705445077
    145 -- optimal, objective: 0.5851578341559628
    146 -- optimal, objective: 4.899534932885463
    147 -- optimal, objective: 3.6822661736354987
    148 -- optimal, objective: 2.121107969962476
    149 -- optimal, objective: 1.7199428397194625
    150 -- optimal, objective: 3.318921498033304
    151 -- optimal, objective: 0.3685188552662235
    152 -- optimal, objective: 1.948810577732557
    153 -- optimal, objective: 2.674787042416041
    154 -- optimal, objective: 7.585656605848237
    155 -- optimal, objective: 3.395738722518712
    156 -- optimal, objective: 4.149600126964649
    157 -- optimal, objective: 1.0001276150027596
    158 -- optimal, objective: 3.064461425586113
    159 -- optimal, objective: 5.013992307955584
    160 -- optimal, objective: 3.8398600172208
    161 -- optimal, objective: 1.657681493601525
    162 -- optimal, objective: 0.4117837889128008
    163 -- optimal, objective: 2.0406846027842356
    164 -- optimal, objective: 2.0029977728129342
    165 -- optimal, objective: 2.511479923619754
    166 -- optimal, objective: 0.4825891465203013
    167 -- optimal, objective: 3.8889766576131994
    168 -- optimal, objective: 1.0769465308219803
    169 -- optimal, objective: 2.499193200877387
    170 -- optimal, objective: 1.8451901671291406
    171 -- optimal, objective: 4.516240233108479
    172 -- optimal, objective: 3.725949852223887
    173 -- optimal, objective: 1.920597530218802
    174 -- optimal, objective: 1.604051376121642
    175 -- optimal, objective: 0.3297073490067821
    176 -- optimal, objective: 3.1773026407631195
    177 -- optimal, objective: 4.892210628679244
    178 -- optimal, objective: 1.734442366701429
    179 -- optimal, objective: 2.093039392251187
    180 -- optimal, objective: 1.982179261190753
    181 -- optimal, objective: 3.095013085176399
    182 -- optimal, objective: 2.562542928308208
    183 -- optimal, objective: 6.469839914005301
    184 -- optimal, objective: 2.0674756021958394
    185 -- optimal, objective: 2.3845462972647335
    186 -- optimal, objective: 1.5119667475376275
    187 -- optimal, objective: 3.625376291000354
    188 -- optimal, objective: 0.9836491008702798
    189 -- optimal, objective: 1.9174021295224033
    190 -- optimal, objective: 1.0200049678539818
    191 -- optimal, objective: 1.8111147486375991
    192 -- optimal, objective: 10.407007486641282
    193 -- optimal, objective: 5.725212636472622
    194 -- optimal, objective: 6.585121023629235
    195 -- optimal, objective: 1.1403803946151982
    196 -- optimal, objective: 4.636496073473516
    197 -- optimal, objective: 3.9217711869842797
    198 -- optimal, objective: 1.004570265746715
    199 -- optimal, objective: 2.418215480546016
    200 -- optimal, objective: 2.924358021526821
    201 -- optimal, objective: 2.968975837966448
    202 -- optimal, objective: 2.6152849723109988
    203 -- optimal, objective: 2.491409118030826
    204 -- optimal, objective: 1.7943475942820328
    205 -- optimal, objective: 5.708286126986155
    206 -- optimal, objective: 2.405602484543316
    207 -- optimal, objective: 0.9383328408601498
    208 -- optimal, objective: 4.796662991507005
    209 -- optimal, objective: 0.5067734258626406
    210 -- optimal, objective: 2.1890884578825083
    211 -- optimal, objective: 3.2162783129747368
    212 -- optimal, objective: 0.07969866183084981
    213 -- optimal, objective: 0.3907166988147673
    214 -- optimal, objective: 4.02400149366669
    215 -- optimal, objective: 3.5942799490590494
    216 -- optimal, objective: 1.677785682737116
    217 -- optimal, objective: 4.8480317039239145
    218 -- optimal, objective: 0.48853441088525273
    219 -- optimal, objective: 12.374570705074118
    220 -- optimal, objective: 1.428411060499977
    221 -- optimal, objective: 1.8180427493588949
    222 -- optimal, objective: 0.4850085026530805
    223 -- optimal, objective: 2.506785181047606
    224 -- optimal, objective: 1.3976812984152978
    225 -- optimal, objective: 0.9031717605985707
    226 -- optimal, objective: 0.7285447496525064
    227 -- optimal, objective: 2.4703912751567594
    228 -- optimal, objective: 2.6751347847312004
    229 -- optimal, objective: 3.3256746125806105
    230 -- optimal, objective: 2.599037298038734
    231 -- optimal, objective: 4.837605778150183
    232 -- optimal, objective: 1.1329234883415549
    233 -- optimal, objective: 1.6398399431865305
    234 -- optimal, objective: 3.008983350550814
    235 -- optimal, objective: 1.4124043086102813
    236 -- optimal, objective: 5.771998515378867
    237 -- optimal, objective: 0.14938906015680678
    238 -- optimal, objective: 1.2057474878060777
    239 -- optimal, objective: 1.716812647150008
    240 -- optimal, objective: 4.602217912756692
    241 -- optimal, objective: 2.123629193962695
    242 -- optimal, objective: 2.5315899941168625
    243 -- optimal, objective: 1.7031408430144872
    244 -- optimal, objective: 2.2177940017210536
    245 -- optimal, objective: 0.6465659506433468
    246 -- optimal, objective: 1.2916365175791176
    247 -- optimal, objective: 7.790245519815119
    248 -- optimal, objective: 1.060558078675606
    249 -- optimal, objective: 1.1515108837628087


.. code:: ipython3

    # Save the reconciled data to be used for parameter estimation
    df_result.to_csv("econ_recon.csv")

.. code:: ipython3

    try:
        # Create a new plot book to compare the original data to the reconciled data.
        da.data_rec_plot_book(
            df_data=df, 
            df_rec=df_result_cmp,
            file="econ_data_rec_plot_book.pdf",
            bin_nom="bin_power", 
            xlabel="gross power (W)", 
            metadata=df_meta
        )
    except:
        print("Plotting failed")


.. parsed-literal::

    Plotting data requires the 'seaborn' and 'PyPDF2' packages. Install the required packages before using the data_book() function.


.. parsed-literal::

    Plotting failed



.. parsed-literal::

    <Figure size 1152x648 with 0 Axes>



.. parsed-literal::

    <Figure size 1152x648 with 0 Axes>


