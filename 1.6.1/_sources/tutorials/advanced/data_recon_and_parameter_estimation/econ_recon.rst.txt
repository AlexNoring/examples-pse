Data Reconciliation for a Single Unit - Economizer
==================================================

This notebook demonstrates data reconciliation with a single unit model,
an economizer. Data for this example was generated by adding noise to
supercritical power plant simulations.

Why reconcile data?
~~~~~~~~~~~~~~~~~~~

Data reconciliation uses mass and energy balances along with redundant
measurements to improve data quality by:

1. reducing measurement error,
2. ensuring measurements satisfy mass and energy balances, and
3. filling in unmeasured quantities.

Data reconciliation is used to refine process data before parameter
estimation.

1. Read Plant Data
------------------

The first step is to read in process data. In this case, data was
simulated by adding measurement error to supercritical steam cycle
simulation results. IDAES includes functions to read process data,
convert units to match a model, and map data to a model.

.. code:: ipython3

    # IDAES module with functions to read, analyze and visualize plant data
    import idaes.dmf.model_data as da
    # Suppress some warnings
    from idaes.logger import getLogger
    import logging
    getLogger('idaes.core').setLevel(logging.ERROR)

Process data is contained in two CSV files, a data file and a metadata
file. The first column in the data file is row indexes and the first row
is process measurement tags. The index column has an entry for each data
row, and is often a time-stamp. The data file format is illustrated by
the table below.

+--------+-----------+-----------+------------+---+
|        | tag1      | tag2      | tag3       | … |
+========+===========+===========+============+===+
| index1 | data(1,1) | data(1,2) | data(1, 3) | … |
+--------+-----------+-----------+------------+---+
| index2 | data(2,1) | data(2,2) | data(2, 3) | … |
+--------+-----------+-----------+------------+---+
| …      | …         | …         | …          | … |
+--------+-----------+-----------+------------+---+

The metadata file contains information about the tags including units of
measurement, description, and model mapping information. The meta data
format is show below, any of the columns my be empty.

|       \| \| \| \| \|

\|——-|— —————|—————|——————-|—————————————————–\| \| tag1 \| model
reference 1 \| description 1 \| unit of measure 1 \| Additional
comments, additional columns are ignored \| \| tag2 \| model reference 2
\| description 2 \| unit of measure 2 \| … \| \| tag3 \| model reference
3 \| description 3 \| unit of measure 3 \| … \| \| … \| … \| … \| … \| …
\|

Once the process data is read in, the data is assigned to bins based on
the value in a given column, in this case gross power. Dividing the data
into bins allows rough estimation of measurement uncertainty.

.. code:: ipython3

    # Read data and column metadata
    df, df_meta = da.read_data("plant_data.csv", "plant_data_meta.csv")
    
    # Add bin information where the data is sorted into 5 MW bins based on the "GROSS_POWER" column
    # A bin number column is added along with a column for nominal gross power in the bin. 
    bin_count = da.bin_data(df, bin_by="POWER_GROSS", bin_no="bin_no", bin_nom="bin_power", bin_size=5e6)
    
    # Calculate the standard deviation by bin for each column.  The resulting standard devations can be 
    # accessed like so: bin_stdev[bin number][column name]
    bin_stdev = da.bin_stdev(df, bin_no="bin_no")

It can be useful to visualize the measurement data and estimated
uncertainty. The following creates box and whisker plots for each tag
based on the data bins. A large number of plots may be created, so to
manage them more easily, they are saved as PDFs and merged into a single
multi-page PDF document. The deafault file name for the resulting PDF is
“data_plot_book.pdf.”

.. code:: ipython3

    # Create a pdf book of plots that shows box and whisker plots for each column by bin
    import os
    if not os.path.isfile("data_plot_book.pdf"):
        da.data_plot_book(df, bin_nom="bin_power", xlabel="gross power (W)", metadata=df_meta, file="data_plot_book.pdf")
    # There should now be a data_plot_book.pdf file in this directory

2. Create Unit model
--------------------

Now that we have the plant data, we need to create a unit model that we
can use for data reconciliation. Although we need a model that has just
mass and energy balances and feasibility constraints for the data
reconciliation problem, we start with the full economizer model here.
Using the same model for data reconciliation, parameter estimation,
validation, and simulation reduces the work required to move between
steps in the workflow.

Once the full model is created, constraints that are not needed for data
reconciliation can be deactivated.

.. code:: ipython3

    # Import models
    from idaes.core import FlowsheetBlock
    from idaes.power_generation.properties.IdealProp_FlueGas import FlueGasParameterBlock
    from idaes.generic_models.properties import iapws95
    from idaes.power_generation.unit_models.boiler_heat_exchanger import (
        BoilerHeatExchanger, 
        TubeArrangement, 
        DeltaTMethod
    )
    import pyomo.environ as pyo

.. code:: ipython3

    # Create flowsheet with economizer
    m = pyo.ConcreteModel()
    m.fs = FlowsheetBlock(default={"dynamic": False})
    m.fs.prop_water = iapws95.Iapws95ParameterBlock()
    m.fs.prop_fluegas = FlueGasParameterBlock()
    
    m.fs.econ = BoilerHeatExchanger(default={
            "side_1_property_package": m.fs.prop_water,
            "side_2_property_package": m.fs.prop_fluegas,
            "has_pressure_change": True,
            "has_holdup": False,
            "delta_T_method": DeltaTMethod.counterCurrent,
            "tube_arrangement": TubeArrangement.inLine,
            "side_1_water_phase": "Liq",
            "has_radiation": False
        }
    )

.. code:: ipython3

    # Set up and initialize the model
    
    # The steam properties use enthalpy as a state variable, so use the known 
    # temperature and pressure to calculate the feedwater inlet enthalpy
    h = iapws95.htpx(563.706, 2.5449e7)
    
    m.fs.econ.side_1_inlet.flow_mol[0].fix(24678.26) # mol/s
    m.fs.econ.side_1_inlet.enth_mol[0].fix(h) #J/mol         
    m.fs.econ.side_1_inlet.pressure[0].fix(2.5449e7) # Pa
    
    # Set the flue gas flow and composition
    fg_rate = 28.3876e3  # mol/s equivalent of ~1930.08 klb/hr
    fg_comp = { # mol fraction of flue gas components
        "H2O":8.69/100,
        "CO2":14.49/100,
        "O2":2.47/100,
        "NO":0.0006,
        "SO2":0.002,
    }
    # The rest is N2
    fg_comp["N2"] = 1 - sum(fg_comp[i] for i in fg_comp)
    
    # Set economizer inlets
    for c in fg_comp:
        m.fs.econ.side_2_inlet.flow_component[0, c].fix(fg_rate*fg_comp[c])    
    m.fs.econ.side_2_inlet.temperature[0].fix(682.335)  # K
    m.fs.econ.side_2_inlet.pressure[0].fix(100145)  # Pa
    
    # Set economizer design variables and parameters
    ITM = 0.0254  # inch to meter conversion
    # Based on NETL Baseline Report Rev4
    m.fs.econ.tube_thickness.fix(0.188*ITM)  # tube thickness
    m.fs.econ.tube_di.fix((2.0 - 2.0 * 0.188)*ITM) # calc inner diameter
    m.fs.econ.pitch_x.fix(3.5*ITM)
    m.fs.econ.pitch_y.fix(5.03*ITM)
    m.fs.econ.tube_length.fix(53.41*12*ITM)  # use tube length (53.41 ft)
    m.fs.econ.tube_nrow.fix(36*2.5) # use to match baseline performance
    m.fs.econ.tube_ncol.fix(130) # 130 from thermoflow
    m.fs.econ.nrow_inlet.fix(2)
    m.fs.econ.delta_elevation.fix(50)
    m.fs.econ.tube_r_fouling = 0.000176
    m.fs.econ.shell_r_fouling = 0.00088
    m.fs.econ.fcorrection_htc.fix(1.5)
    m.fs.econ.fcorrection_dp_tube.fix(1.0)
    m.fs.econ.fcorrection_dp_shell.fix(1.0)

.. code:: ipython3

    # Initialize economizer
    m.fs.econ.initialize(
        state_args_1={
            "flow_mol": m.fs.econ.side_1_inlet.flow_mol[0].value,
            "pressure": m.fs.econ.side_1_inlet.pressure[0].value,
            "enth_mol": m.fs.econ.side_1_inlet.enth_mol[0].value,
        },
        state_args_2={
            "flow_component":{
                "H2O": m.fs.econ.side_2_inlet.flow_component[0, "H2O"].value,
                "CO2": m.fs.econ.side_2_inlet.flow_component[0, "CO2"].value,
                "N2": m.fs.econ.side_2_inlet.flow_component[0, "N2"].value,
                "O2": m.fs.econ.side_2_inlet.flow_component[0, "O2"].value,
                "NO": m.fs.econ.side_2_inlet.flow_component[0, "NO"].value,
                "SO2": m.fs.econ.side_2_inlet.flow_component[0, "SO2"].value,
            },
            "temperature": m.fs.econ.side_2_inlet.temperature[0].value,
            "pressure": m.fs.econ.side_2_inlet.pressure[0].value,
        }
    )


.. parsed-literal::

    2020-07-17 16:24:23 [INFO] idaes.init.fs.econ.side_1: Initialization Complete
    2020-07-17 16:24:23 [INFO] idaes.init.fs.econ.side_2: Initialization Complete
    

3. Simplify to Mass and Energy Balances
---------------------------------------

For data reconciliation, the model should be reduced to mass and energy
balances and potentially limited performance constraints to keep the
results feasible.

.. code:: ipython3

    # Deactivate constraints for heat transfer
    m.fs.econ.overall_heat_transfer_coefficient_eqn.deactivate()
    m.fs.econ.rcond_wall_eqn.deactivate()
    m.fs.econ.hconv_shell_total_eqn.deactivate()
    m.fs.econ.hconv_shell_conv_eqn.deactivate()
    m.fs.econ.N_Nu_shell_eqn.deactivate()
    m.fs.econ.N_Pr_shell_eqn.deactivate()
    m.fs.econ.deltaP_shell_eqn.deactivate()
    m.fs.econ.friction_factor_shell_eqn.deactivate()
    m.fs.econ.N_Re_shell_eqn.deactivate()
    m.fs.econ.v_shell_eqn.deactivate()
    m.fs.econ.hconv_tube_eqn.deactivate()
    m.fs.econ.N_Nu_tube_eqn.deactivate()
    m.fs.econ.N_Pr_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_eqn.deactivate()
    m.fs.econ.deltaP_tube_uturn_eqn.deactivate()
    m.fs.econ.deltaP_tube_friction_eqn.deactivate()
    m.fs.econ.friction_factor_tube_eqn.deactivate()
    m.fs.econ.N_Re_tube_eqn.deactivate()
    m.fs.econ.v_tube_eqn.deactivate()
    m.fs.econ.LMTD.deactivate()

4. Map Data to the Model
------------------------

Although the model mapping can be included in the tag metadata file,
here we just add the mapping information to the tag metadata after
reading the data. Sometime a data set may be used with more than one
model or you may want to examine data before creating a model, in which
case it is convenient to defer mapping the data to the model as we have
done here.

.. code:: ipython3

    df_meta["ECON_OUT_F"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].flow_mol"
    df_meta["ECON_OUT_T"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].temperature"
    df_meta["ECON_OUT_P"]["reference_string"] = "m.fs.econ.side_1.properties_out[:].pressure"
    df_meta["BFW_F"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].flow_mol"
    df_meta["BFW_T"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].temperature"
    df_meta["BFW_P"]["reference_string"] = "m.fs.econ.side_1.properties_in[:].pressure"
    df_meta["FG_2_ECON_Fm"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].flow_mass"
    df_meta["FG_2_ECON_T"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].temperature"
    df_meta["FG_2_ECON_P"]["reference_string"] = "m.fs.econ.side_2.properties_in[:].pressure"
    df_meta["FG_2_AIRPH_Fm"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].flow_mass"
    df_meta["FG_2_AIRPH_T"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].temperature"
    df_meta["FG_2_AIRPH_P"]["reference_string"] = "m.fs.econ.side_2.properties_out[:].pressure"

.. code:: ipython3

    # Add the model references to the tag metadata based on the strings above.
    da.upadate_metadata_model_references(m, df_meta)

.. code:: ipython3

    # Create a dictionary of data tags that we want to use for the data reconciliation problem.  
    # The key is the tag and the value is a reference to a quantity in the model.
    data_tags = {k:v["reference"][0] for k, v in df_meta.items() if v["reference"] is not None}

.. code:: ipython3

    # Now for result output, the data reconciliation usually can give full stream information for a flowsheet
    # including quantities that are unmeasured.  To more easily use the results, it is good practice to map most of
    # the data reconciliation results to flowsheet stream names.  
    import idaes.core.util.tables as ta
    
    # This function creates a dictionary of streams based of streams based on model arcs.  The function
    # also takes an addtional set of stream-like objects for add to the stream dictionary.  In this case,
    # there is a single unit and the flowsheet doesn't contain any arcs, so we add the economized inlet and
    # outlet ports to the stream dictionary.
    stream_dict = ta.arcs_to_stream_dict(
        m, 
        additional={
            "BFW": m.fs.econ.side_1_inlet,
            "ECON_OUT": m.fs.econ.side_1_outlet,
            "FG_2_ECON": m.fs.econ.side_2_inlet,
            "FG_2_AIRPH": m.fs.econ.side_2_outlet,
        },
        sort=True,
    )
    
    # The next function convers the stream dictionary into a dictionary of state block representing the
    # streams at a given time point.  In this case, we have a steady state model, so we only have one 
    # time point (0).
    state_dict = ta.stream_states_dict(stream_dict, time_point=0)
    
    # The 'tag_state_quantities()' function below iterates through the state block dictionary and 
    # creates tags for the listed attributes by combining the state block label with the attribute label 
    # in the labels argument.  For example, pressure in the S001 state block would get the tag 'S001_P'.
    recon_tags = ta.tag_state_quantities(
        blocks=state_dict, 
        attributes=(
            "flow_mass", 
            "flow_mol", 
            "enth_mol", 
            "temperature", 
            "pressure", 
            ("flow_component", "O2"),
            ("flow_component", "NO"),
            ("flow_component", "N2"),
            ("flow_component", "SO2"),
            ("flow_component", "CO2"),
            ("flow_component", "H2O"),
        ), 
        labels=("_Fm", "_F", "_h", "_T", "_P", "_F[O2]", "_F[NO]", "_F[N2]", "_F[SO2]", "_F[CO2]", "_F[H2O]"),
    )
    
    # Any addtional tags can be added.  This is required for tags that cannot be systematically generated 
    # from the model streams.
    recon_tags["ECON_Q"] = m.fs.econ.heat_duty[0]

5. View model flowsheet
-----------------------

Model results or other quantities can be added to a process flow
diagram. The PFD was drawn beforehand and the model results are added to
tagged locations on the PFD.

.. code:: ipython3

    from idaes.core.util.misc import svg_tag  # utility to place numbers/text in an SVG
    
    with open("econ.svg", "r") as f:
        s = svg_tag(svg=f, tags={"subtitle":"Initialized Model"})
        s = svg_tag(svg=s, tags=recon_tags, outfile="econ_init.svg")

.. code:: ipython3

    from IPython.display import SVG, display
    
    display(SVG(s))



.. image:: output_21_0.svg


6. Write Objective
------------------

Next we write the objective function and additional constraints for the
data reconciliation problem. The objective is

.. math:: \min \sum_i \left(\frac{x_{\text{data}, i} - x_{\text{model}, i}}{\sigma_i} \right)^2

Where :math:`i \in \{\text{Measured Quantities}\}` and :math:`\sigma_i`
is the standard deviation of measurement i. In this case, for lack of
better information, the standard deviation was estimated by binning the
data and calculating the standard deviation of each measured variable in
each bin.

.. code:: ipython3

    # Add model parameters to contain measured data.  These are mutable so we can set a specific data point later.
    m.data = pyo.Param(data_tags, mutable=True, doc="Process data for a specific point in time.")
    m.data_stdev = pyo.Param(data_tags, mutable=True, doc="Process data standard deviation.")

.. code:: ipython3

    # The 'set_data' function below takes data from the process data DataFrame and updates the
    # data parameters in the model.
    def set_data(m, df, data_tags, index=None, indexindex=None):
        if index is None:
            index = df.index[indexindex]
        m.bin_no = df.iloc[index]["bin_no"]
        for t in data_tags:
            m.data[t] = df.iloc[index][t]
            m.data_stdev[t] = bin_stdev[m.bin_no][t]

.. code:: ipython3

    # So we have something reasonable to start, set the data attached to the model to the first 
    # data point.
    set_data(m, df, data_tags, indexindex=0)

Add an expression for error divided by the standard deviation, and use
it to write the data reconciliation objective function.

.. code:: ipython3

    @m.Expression(data_tags)
    def err(m, i):
        return (m.data[i] - data_tags[i])/m.data_stdev[i]
    
    m.objective = pyo.Objective(expr=sum(m.err[t]**2 for t in m.err))

Add constraints that ensure reasonable temperature and keep the flue gas
composition correct.

.. code:: ipython3

    # Limit temperature approach
    m.c1 = pyo.Constraint(expr=m.fs.econ.deltaT_1[0] >= 1.0)
    m.c2 = pyo.Constraint(expr=m.fs.econ.deltaT_2[0] >= 1.0)
    
    # Constrain flue gas composition
    m.flow_fg = pyo.Var(initialize=fg_rate)
    @m.Constraint(fg_comp)
    def eq_fg_comp(b, c):
        return m.fs.econ.side_2_inlet.flow_component[0, c] == fg_comp[c]*m.flow_fg

7. Solve Optimization
---------------------

Now we need to solve the data reconciliation problem for every data
point. The important results are stored in two DataFrames ``df_result``,
which contains results tagged based on model stream names to be used in
the parameter estimation step and ``df_result_cmp`` which contains
reconciled data based on the original measurement tags and can be used
to compare the original measurements to the reconciled results.

.. code:: ipython3

    # Make sure the inlet and outlet ports are unfixed.  We want to leave these free 
    # to best match the data.
    m.fs.econ.side_1_inlet.unfix()
    m.fs.econ.side_2_inlet.unfix()
    m.fs.econ.side_1_outlet.unfix()
    m.fs.econ.side_2_outlet.unfix()

.. code:: ipython3

    # Create a Pyomo solver object
    solver = pyo.SolverFactory('ipopt')

.. code:: ipython3

    import pandas as pd
    # Add bin information to reconciliation results so it can be used in parameter estimation
    df_result = pd.DataFrame(columns=list(recon_tags.keys())+["termination", "bin_no", "bin_power"], index=df.index)
    df_result_cmp = pd.DataFrame(columns=list(data_tags.keys())+["termination"], index=df.index)
    
    # Loop through each data point and solve the data reconciliation problem. 
    for i in df.index:
        set_data(m, df, data_tags, index=i)
        res = solver.solve(m)
        tc = str(res.solver.termination_condition)
        df_result.iloc[i]["termination"] = tc
        df_result.iloc[i]["bin_no"] = df.iloc[i]["bin_no"]
        df_result.iloc[i]["bin_power"] = df.iloc[i]["bin_power"]
        df_result_cmp.iloc[i]["termination"] = tc
        for t in recon_tags:
            df_result.iloc[i][t] = pyo.value(recon_tags[t])
        for t in data_tags:
            df_result_cmp.iloc[i][t] = pyo.value(data_tags[t])
        # Show something so you can tell progress is happening
        print(f"{i} -- {tc}, objective: {pyo.value(m.objective)}")


.. parsed-literal::

    0 -- optimal, objective: 3.1622013606258323
    1 -- optimal, objective: 0.8197916348691271
    2 -- optimal, objective: 1.4704841795759487
    3 -- optimal, objective: 1.1898903619192303
    4 -- optimal, objective: 6.266902064585197
    5 -- optimal, objective: 2.353798975733188
    6 -- optimal, objective: 0.523236233470275
    7 -- optimal, objective: 1.0234347889956799
    8 -- optimal, objective: 1.6923646000307904
    9 -- optimal, objective: 5.200181602792017
    10 -- optimal, objective: 2.025678883244299
    11 -- optimal, objective: 1.3755282573108119
    12 -- optimal, objective: 1.8040411950227633
    13 -- optimal, objective: 1.0820452722033682
    14 -- optimal, objective: 2.872550834678523
    15 -- optimal, objective: 4.6794314017712395
    16 -- optimal, objective: 2.5285462489987105
    17 -- optimal, objective: 3.4190566068992694
    18 -- optimal, objective: 0.6733248046041042
    19 -- optimal, objective: 1.319117422958565
    20 -- optimal, objective: 2.5911263697631206
    21 -- optimal, objective: 0.7284969800023046
    22 -- optimal, objective: 3.0960880080306734
    23 -- optimal, objective: 8.046882712392648
    24 -- optimal, objective: 9.434438819029108
    25 -- optimal, objective: 2.908666060555752
    26 -- optimal, objective: 5.76485477632321
    27 -- optimal, objective: 1.5869850001202876
    28 -- optimal, objective: 0.9849706870360087
    29 -- optimal, objective: 5.420696622705007
    30 -- optimal, objective: 0.16069807809737868
    31 -- optimal, objective: 1.9662633227541704
    32 -- optimal, objective: 4.631928468439302
    33 -- optimal, objective: 0.7898326457669774
    34 -- optimal, objective: 4.935316816207516
    35 -- optimal, objective: 2.782217553676702
    36 -- optimal, objective: 3.7936042118832582
    37 -- optimal, objective: 7.399694410587616
    38 -- optimal, objective: 1.8234931889047845
    39 -- optimal, objective: 8.123278203552243
    40 -- optimal, objective: 2.46698933026375
    41 -- optimal, objective: 2.059053759504663
    42 -- optimal, objective: 4.8248900459121975
    43 -- optimal, objective: 2.9053626799318653
    44 -- optimal, objective: 1.2572997144475635
    45 -- optimal, objective: 2.7626453809391314
    46 -- optimal, objective: 3.9106046062612636
    47 -- optimal, objective: 0.36384547188937144
    48 -- optimal, objective: 6.482123086792301
    49 -- optimal, objective: 0.8862884524239143
    50 -- optimal, objective: 0.3533378896238835
    51 -- optimal, objective: 0.6741934666895475
    52 -- optimal, objective: 1.4465665980891864
    53 -- optimal, objective: 2.3656921156999395
    54 -- optimal, objective: 1.4292836233967758
    55 -- optimal, objective: 11.608835808935947
    56 -- optimal, objective: 2.5845585364935517
    57 -- optimal, objective: 2.228031835877884
    58 -- optimal, objective: 2.4953939655520303
    59 -- optimal, objective: 1.64728875900746
    60 -- optimal, objective: 8.024825566331522
    61 -- optimal, objective: 5.943553444690236
    62 -- optimal, objective: 2.3357860625600346
    63 -- optimal, objective: 4.385139025177312
    64 -- optimal, objective: 0.5607805981597906
    65 -- optimal, objective: 2.1768471356354873
    66 -- optimal, objective: 2.8232836736977323
    67 -- optimal, objective: 4.396906443658432
    68 -- optimal, objective: 3.3918559300376
    69 -- optimal, objective: 0.6148795243219267
    70 -- optimal, objective: 0.3708280914480344
    71 -- optimal, objective: 0.8762641868566469
    72 -- optimal, objective: 3.0086342942205486
    73 -- optimal, objective: 6.178275683704583
    74 -- optimal, objective: 2.451595716772191
    75 -- optimal, objective: 8.974736425709315
    76 -- optimal, objective: 1.7706655882254374
    77 -- optimal, objective: 3.126518971476656
    78 -- optimal, objective: 5.205386216685993
    79 -- optimal, objective: 4.769597864830353
    80 -- optimal, objective: 4.816644746436775
    81 -- optimal, objective: 0.6532812835413797
    82 -- optimal, objective: 2.4965181358356214
    83 -- optimal, objective: 0.8032343482261983
    84 -- optimal, objective: 0.36282493375353664
    85 -- optimal, objective: 1.5238238194806737
    86 -- optimal, objective: 3.8657878309489013
    87 -- optimal, objective: 1.7222749668706538
    88 -- optimal, objective: 3.9538769694017883
    89 -- optimal, objective: 1.6523612442371824
    90 -- optimal, objective: 3.3510638416840344
    91 -- optimal, objective: 1.209395519639998
    92 -- optimal, objective: 1.578704532136329
    93 -- optimal, objective: 3.4104193014724813
    94 -- optimal, objective: 1.263897891350234
    95 -- optimal, objective: 3.2950093864132977
    96 -- optimal, objective: 1.5306978267035247
    97 -- optimal, objective: 2.0576162766855504
    98 -- optimal, objective: 1.7332102521609027
    99 -- optimal, objective: 4.588275042310423
    100 -- optimal, objective: 0.9295646078236883
    101 -- optimal, objective: 1.103556128419626
    102 -- optimal, objective: 0.005402403281227689
    103 -- optimal, objective: 4.030350825818049
    104 -- optimal, objective: 2.597768847187468
    105 -- optimal, objective: 3.718657215196669
    106 -- optimal, objective: 2.2200012303854417
    107 -- optimal, objective: 1.736182167287637
    108 -- optimal, objective: 1.782794817352393
    109 -- optimal, objective: 0.8012022277038306
    110 -- optimal, objective: 0.4890697265298109
    111 -- optimal, objective: 4.625396349831095
    112 -- optimal, objective: 4.073050044232986
    113 -- optimal, objective: 4.984164789951575
    114 -- optimal, objective: 4.500918344081846
    115 -- optimal, objective: 0.8012413198266244
    116 -- optimal, objective: 2.6875434017647444
    117 -- optimal, objective: 6.86493437908063
    118 -- optimal, objective: 3.037580586181626
    119 -- optimal, objective: 2.4941088890247975
    120 -- optimal, objective: 0.46083351785486115
    121 -- optimal, objective: 0.04447133159167581
    122 -- optimal, objective: 1.909182664526004
    123 -- optimal, objective: 4.153927862805079
    124 -- optimal, objective: 5.635821162569034
    125 -- optimal, objective: 4.722448584729789
    126 -- optimal, objective: 4.838425864545334
    127 -- optimal, objective: 2.8953598470321937
    128 -- optimal, objective: 0.1700702801123608
    129 -- optimal, objective: 0.9837813189594975
    130 -- optimal, objective: 8.05224454496612
    131 -- optimal, objective: 6.260349530090938
    132 -- optimal, objective: 2.572638735016645
    133 -- optimal, objective: 3.73323064993653
    134 -- optimal, objective: 0.3400649625009756
    135 -- optimal, objective: 3.603279268838218
    136 -- optimal, objective: 2.5015728490600546
    137 -- optimal, objective: 0.3964133949983703
    138 -- optimal, objective: 0.1414040424712123
    139 -- optimal, objective: 8.317240586450241
    140 -- optimal, objective: 5.42444870951965
    141 -- optimal, objective: 2.8357713483581333
    142 -- optimal, objective: 1.5375770466937337
    143 -- optimal, objective: 3.6241716128087664
    144 -- optimal, objective: 4.954731705445061
    145 -- optimal, objective: 0.5851578341559874
    146 -- optimal, objective: 4.899534932885194
    147 -- optimal, objective: 3.6822661736354982
    148 -- optimal, objective: 2.121107969962575
    149 -- optimal, objective: 1.7199428397194763
    150 -- optimal, objective: 3.3189214980333306
    151 -- optimal, objective: 0.36851885526621403
    152 -- optimal, objective: 1.9488105777325042
    153 -- optimal, objective: 2.674787042415955
    154 -- optimal, objective: 7.585656605848053
    155 -- optimal, objective: 3.3957387225187112
    156 -- optimal, objective: 4.149600126964533
    157 -- optimal, objective: 1.0001276150026863
    158 -- optimal, objective: 3.0644614255860705
    159 -- optimal, objective: 5.013992307955607
    160 -- optimal, objective: 3.8398600172211
    161 -- optimal, objective: 1.6576814936015702
    162 -- optimal, objective: 0.41178378891272593
    163 -- optimal, objective: 2.040684602784193
    164 -- optimal, objective: 2.0029977728129227
    165 -- optimal, objective: 2.5114799236196643
    166 -- optimal, objective: 0.4825891465203669
    167 -- optimal, objective: 3.888976657613061
    168 -- optimal, objective: 1.07694653082199
    169 -- optimal, objective: 2.4991932008773876
    170 -- optimal, objective: 1.8451901671291322
    171 -- optimal, objective: 4.516240233108405
    172 -- optimal, objective: 3.725949852223886
    173 -- optimal, objective: 1.920597530218781
    174 -- optimal, objective: 1.6040513761216326
    175 -- optimal, objective: 0.3297073490067809
    176 -- optimal, objective: 3.1773026407630907
    177 -- optimal, objective: 4.892210628679246
    178 -- optimal, objective: 1.734442366701537
    179 -- optimal, objective: 2.0930393922511805
    180 -- optimal, objective: 1.9821792611906741
    181 -- optimal, objective: 3.0950130851764084
    182 -- optimal, objective: 2.5625429283081047
    183 -- optimal, objective: 6.469839914005335
    184 -- optimal, objective: 2.0674756021958216
    185 -- optimal, objective: 2.3845462972648566
    186 -- optimal, objective: 1.5119667475376197
    187 -- optimal, objective: 3.625376291000162
    188 -- optimal, objective: 0.9836491008702384
    189 -- optimal, objective: 1.9174021295224848
    190 -- optimal, objective: 1.0200049678539824
    191 -- optimal, objective: 1.8111147486376113
    192 -- optimal, objective: 10.407007486641458
    193 -- optimal, objective: 5.725212636472864
    194 -- optimal, objective: 6.585121023629498
    195 -- optimal, objective: 1.1403803946151516
    196 -- optimal, objective: 4.63649607347344
    197 -- optimal, objective: 3.9217711869840994
    198 -- optimal, objective: 1.0045702657467035
    199 -- optimal, objective: 2.418215480545959
    200 -- optimal, objective: 2.92435802152688
    201 -- optimal, objective: 2.9689758379664286
    202 -- optimal, objective: 2.615284972310984
    203 -- optimal, objective: 2.4914091180308464
    204 -- optimal, objective: 1.7943475942820328
    205 -- optimal, objective: 5.708286126985967
    206 -- optimal, objective: 2.405602484543313
    207 -- optimal, objective: 0.9383328408601793
    208 -- optimal, objective: 4.7966629915070715
    209 -- optimal, objective: 0.5067734258626303
    210 -- optimal, objective: 2.1890884578825514
    211 -- optimal, objective: 3.216278312974754
    212 -- optimal, objective: 0.07969866183085542
    213 -- optimal, objective: 0.3907166988147584
    214 -- optimal, objective: 4.0240014936663915
    215 -- optimal, objective: 3.594279949058917
    216 -- optimal, objective: 1.6777856827371203
    217 -- optimal, objective: 4.848031703923873
    218 -- optimal, objective: 0.4885344108852833
    219 -- optimal, objective: 12.37457070507444
    220 -- optimal, objective: 1.4284110605000004
    221 -- optimal, objective: 1.8180427493589018
    222 -- optimal, objective: 0.4850085026530655
    223 -- optimal, objective: 2.506785181047701
    224 -- optimal, objective: 1.3976812984153097
    225 -- optimal, objective: 0.9031717605985998
    226 -- optimal, objective: 0.7285447496525917
    227 -- optimal, objective: 2.470391275156837
    228 -- optimal, objective: 2.6751347847312803
    229 -- optimal, objective: 3.325674612580548
    230 -- optimal, objective: 2.599037298038793
    231 -- optimal, objective: 4.837605778150097
    232 -- optimal, objective: 1.1329234883415304
    233 -- optimal, objective: 1.639839943186599
    234 -- optimal, objective: 3.008983350550902
    235 -- optimal, objective: 1.412404308610275
    236 -- optimal, objective: 5.771998515378807
    237 -- optimal, objective: 0.1493890601568089
    238 -- optimal, objective: 1.205747487806092
    239 -- optimal, objective: 1.7168126471500995
    240 -- optimal, objective: 4.602217912756654
    241 -- optimal, objective: 2.123629193962625
    242 -- optimal, objective: 2.531589994116715
    243 -- optimal, objective: 1.703140843014368
    244 -- optimal, objective: 2.2177940017210767
    245 -- optimal, objective: 0.6465659506433573
    246 -- optimal, objective: 1.291636517579119
    247 -- optimal, objective: 7.79024551981515
    248 -- optimal, objective: 1.0605580786755044
    249 -- optimal, objective: 1.1515108837628596
    

.. code:: ipython3

    # Save the reconciled data to be used for parameter estimation
    df_result.to_csv("econ_recon.csv")

.. code:: ipython3

    try:
        # Create a new plot book to compare the original data to the reconciled data.
        da.data_rec_plot_book(
            df_data=df, 
            df_rec=df_result_cmp,
            file="econ_data_rec_plot_book.pdf",
            bin_nom="bin_power", 
            xlabel="gross power (W)", 
            metadata=df_meta
        )
    except:
        print("Plotting failed")


.. parsed-literal::

    Plotting data requires the 'seaborn' and 'PyPDF2' packages. Install the required packages before using the data_book() function. Plot terminated.
    

